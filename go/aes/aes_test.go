package aes

import (
	"testing"
)

func TestAESCipherRound(t *testing.T) {
	// Test vector for a single AES round
	block := [16]byte{0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff}
	key := [16]byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}

	// Test with hardware intrinsics (if available)
	blockHW := block
	CipherRound(&blockHW, &key)

	// Test with generic implementation
	blockSW := block
	CipherRoundGeneric(&blockSW, &key)

	// Both should produce the same result
	if blockHW != blockSW {
		t.Errorf("Hardware and software implementations produce different results\nHW: %x\nSW: %x", blockHW, blockSW)
	}
}

func BenchmarkAESCipherRound(b *testing.B) {
	block := [16]byte{0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff}
	key := [16]byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}

	b.Run("Hardware", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			CipherRound(&block, &key)
		}
	})

	b.Run("Software", func(b *testing.B) {
		for i := 0; i < b.N; i++ {
			CipherRoundGeneric(&block, &key)
		}
	})
}
